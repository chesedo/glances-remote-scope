var http = require('http');
var scopes = require('unity-js-scopes');

var GlancesData = function(server, port, callback, error) {
    // Get data values from http.get reponse
    var getData = function(response) {
        var res = '';

        // Another chunk of data has been recieved, so append it to res
        response.on('data', function(chunk) {
            clearTimeout(timeout);
            res += chunk;
        });

        // The whole response has been recieved
        response.on('end', function() {
            this.data = JSON.parse(res);

            // Also get limits
            http.get(
                {host: server, path: "/api/2/all/limits", port: port},
                getLimits.bind(this)
            ).on('error', error);
        }.bind(this));
    }

    // Get limits from http.get reponse
    var getLimits = function(response) {
        var res = '';

        // Another chunk of data has been recieved, so append it to res
        response.on('data', function(chunk) {
            clearTimeout(timeout);
            res += chunk;
        });

        // The whole response has been recieved
        response.on('end', function() {
            this.limits = JSON.parse(res);

            callback();
        }.bind(this));
    }

    var request = http.get(
        {host: server, path: "/api/2/all", port: port},
        getData.bind(this)
    ).on('error', error);

    // IP requests hangs for some reason. This moves it along
    var timeout = setTimeout(function() {}, 3000);
}

// Get a key value seperated by underscores
GlancesData.prototype.getValue = function(item) {
    var itemBreakdown = item.split("_");
    var itemBreakdownLength = itemBreakdown.length;
    var value = this.data;

    for (var i = 0; i < itemBreakdownLength; i++) {
        value = value[itemBreakdown[i]];
    }

    return value;
}

// Get a percent value
GlancesData.prototype.getPercentValue = function(item) {
    return this.getValue(item) + "%"
}

// Get a data value
GlancesData.prototype.getDataValue = function(item) {
    return this.convertByte(this.getValue(item));
}

// Convert a number(bytes) to a data number
GlancesData.prototype.convertByte = function(byte) {
    var value = byte;
    var levels = ["b","Kb", "Mb", "Gb", "Tb", "Pb", "Eb"];

    for (var i = 0; i < levels.length; i++) {
        if (value < 1024) {
            if (value > 10) {
                return value.toFixed(0) + levels[i];
            } else {
                // Not using fixed so that 5Gb does not show 5.00Gb
                return Math.round(value * 100) / 100 + levels[i];
            }
        }

        value /= 1024;
    }
}

// Get data rate value
GlancesData.prototype.getDataRateValue = function(item) {
    return this.convertByteRate(this.getValue(item));
}

// Convert a number(bytes) to a data rate number
GlancesData.prototype.convertByteRate = function(byte) {
    return this.convertByte(byte) + "/s"
}

// Get the total disk IO
GlancesData.prototype.getTotalDiskIO = function() {
    // Reuse old computation to safe processing power
    if (this.totalDiskIO !== undefined) {
        return this.totalDiskIO
    }

    this.totalDiskIO = {"write_bytes": 0, "read_bytes": 0};

    this.data.diskio.forEach(function(io) {
        this.totalDiskIO["write_bytes"] += io["write_bytes"] / io["time_since_update"];
        this.totalDiskIO["read_bytes"] += io["read_bytes"] / io["time_since_update"];
    }.bind(this));

    return this.totalDiskIO
}

// Get total network IO
GlancesData.prototype.getTotalNetworkIO = function() {
    // Reuse old computation to safe processing power
    if (this.totalNetworkIO !== undefined) {
        return this.totalNetworkIO
    }

    this.totalNetworkIO = {"cx": 0, "tx": 0, "rx": 0};

    this.data.network.forEach(function(io) {
        this.totalNetworkIO["tx"] += io["tx"] / io["time_since_update"];
        this.totalNetworkIO["rx"] += io["rx"] / io["time_since_update"];
        this.totalNetworkIO["cx"] += io["cx"] / io["time_since_update"];
    }.bind(this));

    return this.totalNetworkIO
}

// Get emblem based on alert
GlancesData.prototype.getAlertEmblem = function(alert) {
    return this.levelToEmblem(alert[2])
}

// Get the level of an item based on its value
GlancesData.prototype.getLevel = function(item) {
    var itemBreakdown = item.split("_")
    var value = this.data[itemBreakdown[0]][itemBreakdown[1]];

    if (value > this.limits[itemBreakdown[0]][item + "_critical"] || value > this.limits[itemBreakdown[0]][itemBreakdown[0] + "_critical"]) {
        return "CRITICAL"
    } else if (value > this.limits[itemBreakdown[0]][item + "_warning"] || value > this.limits[itemBreakdown[0]][itemBreakdown[0] + "_warning"]) {
        return "WARNING"
    } else if (value > this.limits[itemBreakdown[0]][item + "_careful"] || value > this.limits[itemBreakdown[0]][itemBreakdown[0] + "_careful"]) {
        return "CAREFUL"
    } else {
        return ""
    }
}

// Get the emblem of an item based on its value
GlancesData.prototype.getEmblem = function(item) {
    return this.levelToEmblem(this.getLevel(item))
}

// Get the emblem for a level
GlancesData.prototype.levelToEmblem = function(level) {
    if (level !== "") {
        return "file:///" + scopes.self.scope_directory + "/emblems/" + level.toLowerCase() + ".svg"
    }

    return level
}

// Get the emblem for filesystems
GlancesData.prototype.getFSEmblem = function(value) {
    var level = "";

    if (value > this.limits.fs["fs_critical"]) {
        level =  "CRITICAL"
    } else if (value > this.limits.fs["fs_warning"]) {
        level =  "WARNING"
    } else if (value > this.limits.fs["fs_careful"]) {
        level = "CAREFUL"
    }

    return this.levelToEmblem(level)
}

// Get the emblem for processes
GlancesData.prototype.getProcessEmblem = function(process) {
    var level = "";

    if (process["memory_percent"] > this.limits.processlist["processlist_mem_critical"] || process["cpu_percent"] > this.limits.processlist["processlist_cpu_critical"]) {
        level =  "CRITICAL"
    } else if (process["memory_percent"] > this.limits.processlist["processlist_mem_warning"] || process["cpu_percent"] > this.limits.processlist["processlist_cpu_warning"]) {
        level =  "WARNING"
    } else if (process["memory_percent"] > this.limits.processlist["processlist_mem_careful"] || process["cpu_percent"] > this.limits.processlist["processlist_cpu_careful"]) {
        level = "CAREFUL"
    }

    return this.levelToEmblem(level)
}

GlancesData.prototype.hasDocker = function() {
    return this.data.docker.version !== undefined
}

exports.GlancesData = GlancesData;
